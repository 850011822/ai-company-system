# AI 公司系统 - 完整部署教程

## 系统概述

这是一个基于 CrewAI 框架构建的全自动化 AI 公司系统。该系统模拟了一个完整的公司架构，包含多个专业 AI Agent 协同工作，实现自主学习、技术迭代、市场分析和商业变现能力。

### 核心功能

- **自主学习**：AI Agent 自动追踪前沿技术，持续更新知识库
- **自我迭代**：系统自动评估能力差距并实施优化
- **市场分析**：实时扫描市场机会，评估商业可行性
- **项目执行**：将商业想法转化为可交付产品

---

## 技术栈

| 组件 | 说明 |
|------|------|
| CrewAI | 多 Agent 协作框架 |
| Python 3.11+ | 运行环境 |
| OpenAI API | 大语言模型（支持兼容 API） |
| SQLite/向量数据库 | 记忆存储 |

---

## 第一步：环境准备

### 1.1 安装 Python

确保您的系统已安装 Python 3.11 或更高版本：

```bash
# 检查 Python 版本
python --version

# 如果未安装，请访问 https://www.python.org/downloads/
```

### 1.2 创建项目目录

```bash
# 创建项目文件夹
mkdir -p ~/ai-company
cd ~/ai-company

# 创建子目录
mkdir -p agents tools memory logs output
```

### 1.3 创建虚拟环境

```bash
# 使用 venv 创建虚拟环境
python -m venv venv

# 激活虚拟环境
# Linux/Mac:
source venv/bin/activate

# Windows:
venv\Scripts\activate
```

---

## 第二步：安装依赖

### 2.1 安装 CrewAI 核心包

```bash
# 安装 CrewAI 及相关工具
pip install crewai crewai-tools

# 安装其他依赖
pip install python-dotenv requests pandas
```

### 2.2 配置文件准备

在项目根目录创建 `.env` 文件：

```bash
# .env 文件内容
OPENAI_API_KEY=your_api_key_here
OPENAI_API_BASE=https://api.openai.com/v1
MODEL_NAME=gpt-4o-mini
```

> **注意**：如果您使用 Ollama 或其他本地模型，请相应调整配置。

---

## 第三步：项目文件部署

### 3.1 创建主程序文件

将以下代码保存为 `main.py`：

```python
"""
AI 公司系统 - 主程序入口
"""
import os
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process
from crewai.tools import tool
from langchain_community.tools import DuckDuckGoSearchResultsTool
import requests

# 加载环境变量
load_dotenv()

# ==================== 工具定义 ====================

@tool("web_search")
def web_search(query: str) -> str:
    """使用DuckDuckGo搜索最新信息"""
    search = DuckDuckGoSearchResultsTool()
    return search.run(query)

@tool("fetch_web_content")
def fetch_web_content(url: str) -> str:
    """获取网页内容"""
    try:
        response = requests.get(url, timeout=10)
        return response.text[:5000]  # 限制返回长度
    except Exception as e:
        return f"获取失败: {str(e)}"

# ==================== Agent 定义 ====================

def create_cto_agent():
    """创建 CTO Agent - 首席技术官"""
    return Agent(
        role="首席技术官 (CTO)",
        goal="持续追踪AI领域前沿技术，将新技术转化为公司能力",
        backstory="""
        您是公司的首席技术官，拥有深厚的技术背景和敏锐的技术洞察力。
        您的职责是确保公司始终掌握最新技术，保持竞争优势。
        您擅长技术调研、知识转化和技术路线规划。
        """,
        tools=[web_search, fetch_web_content],
        verbose=True,
        allow_delegation=False
    )

def create_coo_agent():
    """创建 COO Agent - 首席运营官"""
    return Agent(
        role="首席运营官 (COO)",
        goal="优化公司运营效率，持续提升系统能力",
        backstory="""
        您是公司的首席运营官，精通系统优化和流程改进。
        您的职责是评估现有能力，找出差距，制定并执行优化方案。
        您擅长数据分析、流程优化和质量控制。
        """,
        tools=[web_search],
        verbose=True,
        allow_delegation=False
    )

def create_cmo_agent():
    """创建 CMO Agent - 首席市场官"""
    return Agent(
        role="首席市场官 (CMO)",
        goal="敏锐洞察市场机会，识别商业变现可能",
        backstory="""
        您是公司的首席市场官，拥有敏锐的商业嗅觉和出色的分析能力。
        您的职责是扫描市场动态，发现机会，评估可行性。
        您擅长市场分析、竞争分析和商业策划。
        """,
        tools=[web_search, fetch_web_content],
        verbose=True,
        allow_delegation=False
    )

def create_cpo_agent():
    """创建 CPO Agent - 首席产品官"""
    return Agent(
        role="首席产品官 (CPO)",
        goal="将商业想法转化为可交付的产品和服务",
        backstory="""
        您是公司的首席产品官，拥有出色的产品开发和项目管理能力。
        您的职责是执行项目，开发产品，确保交付质量。
        您擅长产品设计、代码开发和项目管理。
        """,
        tools=[web_search],
        verbose=True,
        allow_delegation=False
    )

# ==================== 任务定义 ====================

def create_research_task(agent, topic):
    """创建技术研究任务"""
    return Task(
        description=f"""
        请深入研究以下技术主题：{topic}

        要求：
        1. 搜索最新的技术发展和行业动态
        2. 分析该技术的核心原理和应用场景
        3. 评估该技术对公司能力的提升价值
        4. 提出具体的技术应用建议
        """,
        agent=agent,
        expected_output="详细的技术调研报告，包含核心发现、应用建议和实施计划"
    )

def create_market_task(agent, focus_area):
    """创建市场分析任务"""
    return Task(
        description=f"""
        请分析以下市场的商业机会：{focus_area}

        要求：
        1. 扫描市场现状和趋势
        2. 识别潜在客户群体和需求
        3. 评估竞争格局和机会
        4. 提出可行的商业模式建议
        """,
        agent=agent,
        expected_output="市场分析报告，包含机会评估和商业建议"
    )

def create_optimization_task(agent, focus_area):
    """创建优化任务"""
    return Task(
        description=f"""
        请分析并优化以下领域：{focus_area}

        要求：
        1. 评估当前能力水平
        2. 对比行业最佳实践
        3. 识别差距和改进点
        4. 制定优化方案
        """,
        agent=agent,
        expected_output="优化方案报告，包含差距分析和实施计划"
    )

# ==================== 工作流 ====================

def run_tech_research(topic):
    """运行技术研究工作流"""
    cto = create_cto_agent()
    task = create_research_task(cto, topic)

    crew = Crew(
        agents=[cto],
        tasks=[task],
        process=Process.sequential,
        verbose=True
    )

    result = crew.kickoff()
    return result

def run_market_analysis(focus_area):
    """运行市场分析工作流"""
    cmo = create_cmo_agent()
    task = create_market_task(cmo, focus_area)

    crew = Crew(
        agents=[cmo],
        tasks=[task],
        process=Process.sequential,
        verbose=True
    )

    result = crew.kickoff()
    return result

def run_optimization(focus_area):
    """运行优化工作流"""
    coo = create_coo_agent()
    task = create_optimization_task(coo, focus_area)

    crew = Crew(
        agents=[coo],
        tasks=[task],
        process=Process.sequential,
        verbose=True
    )

    result = crew.kickoff()
    return result

# ==================== 主程序 ====================

if __name__ == "__main__":
    print("=" * 60)
    print("       AI 公司系统 - 自主运营平台")
    print("=" * 60)
    print()
    print("请选择运行模式：")
    print("1. 技术研究 (CTO)")
    print("2. 市场分析 (CMO)")
    print("3. 能力优化 (COO)")
    print("4. 退出")
    print()

    choice = input("请输入选项 (1-4): ")

    if choice == "1":
        topic = input("请输入研究主题: ")
        print("\n正在启动技术研究...\n")
        result = run_tech_research(topic)
        print("\n" + "=" * 60)
        print("研究结果：")
        print("=" * 60)
        print(result)

    elif choice == "2":
        focus = input("请输入分析领域: ")
        print("\n正在启动市场分析...\n")
        result = run_market_analysis(focus)
        print("\n" + "=" * 60)
        print("分析结果：")
        print("=" * 60)
        print(result)

    elif choice == "3":
        focus = input("请输入优化领域: ")
        print("\n正在启动优化分析...\n")
        result = run_optimization(focus)
        print("\n" + "=" * 60)
        print("优化建议：")
        print("=" * 60)
        print(result)

    else:
        print("感谢使用！")
```

### 3.2 创建高级版本（可选）

如果您需要更高级的功能（如长期记忆、自动化调度），请使用 `main_advanced.py`：

```python
"""
AI 公司系统 - 高级版
包含：长期记忆、自动化调度、多工作流
"""
import os
import json
import sqlite3
from datetime import datetime
from dotenv import load_dotenv
from crewai import Agent, Task, Crew, Process
from crewai.tools import tool
from langchain_community.tools import DuckDuckGoSearchResultsTool
import requests
import time
import threading

# 加载环境变量
load_dotenv()

# ==================== 记忆系统 ====================

class MemorySystem:
    """长期记忆系统"""

    def __init__(self, db_path="memory/company_memory.db"):
        self.db_path = db_path
        os.makedirs(os.path.dirname(db_path), exist_ok=True)
        self._init_db()

    def _init_db(self):
        """初始化数据库"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        c.execute('''CREATE TABLE IF NOT EXISTS memories
                     (id INTEGER PRIMARY KEY,
                      category TEXT,
                      content TEXT,
                      timestamp TEXT)''')
        conn.commit()
        conn.close()

    def save(self, category, content):
        """保存记忆"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        c.execute("INSERT INTO memories (category, content, timestamp) VALUES (?, ?, ?)",
                  (category, content, datetime.now().isoformat()))
        conn.commit()
        conn.close()

    def search(self, category, keyword):
        """搜索记忆"""
        conn = sqlite3.connect(self.db_path)
        c = conn.cursor()
        c.execute("SELECT content FROM memories WHERE category=? AND content LIKE ?",
                  (category, f'%{keyword}%'))
        results = c.fetchall()
        conn.close()
        return [r[0] for r in results]

# ==================== 工具定义 ====================

@tool("web_search")
def web_search(query: str) -> str:
    """使用DuckDuckGo搜索最新信息"""
    search = DuckDuckGoSearchResultsTool()
    return search.run(query)

@tool("save_to_memory")
def save_to_memory(category: str, content: str) -> str:
    """保存信息到长期记忆"""
    memory = MemorySystem()
    memory.save(category, content)
    return "记忆已保存"

# ==================== Agent 工厂 ====================

def create_ceo_agent():
    """CEO Agent - 战略决策"""
    return Agent(
        role="首席执行官 (CEO)",
        goal="制定公司战略，协调各部门工作",
        backstory="您是公司的CEO，负责整体战略规划和资源分配。",
        verbose=True
    )

def create_cto_agent():
    """CTO Agent - 技术研发"""
    return Agent(
        role="首席技术官 (CTO)",
        goal="追踪前沿技术，提升技术能力",
        backstory="您是CTO，负责技术调研和能力提升。",
        tools=[web_search, save_to_memory],
        verbose=True
    )

# ==================== 工作流引擎 ====================

class WorkflowEngine:
    """自动化工作流引擎"""

    def __init__(self):
        self.memory = MemorySystem()
        self.running = False

    def start_auto_mode(self, interval=3600):
        """启动自动模式（每秒检查一次）"""
        self.running = True
        print(f"自动模式已启动，每 {interval} 秒执行一次循环")

        while self.running:
            self._run_cycle()
            time.sleep(interval)

    def _run_cycle(self):
        """执行一个循环"""
        print("\n" + "="*40)
        print(f"执行周期: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*40)

        # 1. 技术扫描
        cto = create_cto_agent()
        task = Task(
            description="搜索AI领域最新技术动态",
            agent=cto,
            expected_output="技术趋势摘要"
        )
        crew = Crew(agents=[cto], tasks=[task])
        result = crew.kickoff()

        # 2. 保存到记忆
        self.memory.save("tech_trends", str(result))

        print(f"本周期完成，结果已保存")

    def stop(self):
        """停止自动模式"""
        self.running = False

# ==================== 主程序 ====================

if __name__ == "__main__":
    print("=" * 60)
    print("       AI 公司系统 - 高级版")
    print("=" * 60)
    print()
    print("模式选择：")
    print("1. 手动模式 - 交互式执行任务")
    print("2. 自动模式 - 周期性自动运行")
    print("3. 退出")
    print()

    choice = input("请输入选项: ")

    if choice == "1":
        # 手动模式
        topic = input("请输入研究主题: ")
        cto = create_cto_agent()
        task = Task(description=f"研究: {topic}", agent=cto)
        crew = Crew(agents=[cto], tasks=[task])
        print(crew.kickoff())

    elif choice == "2":
        # 自动模式
        interval = int(input("运行间隔（秒）[默认3600]: ") or "3600")
        engine = WorkflowEngine()
        try:
            engine.start_auto_mode(interval)
        except KeyboardInterrupt:
            engine.stop()
            print("\n已停止")
```

---

## 第四步：运行系统

### 4.1 基础运行

```bash
# 激活虚拟环境
source venv/bin/activate  # Linux/Mac
# 或
venv\Scripts\activate     # Windows

# 运行主程序
python main.py
```

### 4.2 交互示例

```
============================================================
       AI 公司系统 - 自主运营平台
============================================================

请选择运行模式：
1. 技术研究 (CTO)
2. 市场分析 (CMO)
3. 能力优化 (COO)
4. 退出

请输入选项 (1-4): 1
请输入研究主题: AI Agent工作流自动化

正在启动技术研究...

[Agent输出...]
```

---

## 第五步：进阶配置

### 5.1 使用 Ollama 本地模型

```python
# 修改 .env 文件
OPENAI_API_KEY=dummy
OPENAI_API_BASE=http://localhost:11434/v1
MODEL_NAME=llama2
```

### 5.2 使用硅基流动 API

```python
# .env 配置
OPENAI_API_KEY=your_silicon_key
OPENAI_API_BASE=https://api.siliconflow.cn/v1
MODEL_NAME=Qwen/Qwen2.5-7B-Instruct
```

### 5.3 Docker 部署

创建 `Dockerfile`：

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "main.py"]
```

构建运行：

```bash
docker build -t ai-company .
docker run -it ai-company
```

---

## 常见问题

### Q1: API 调用失败

确保：
1. `.env` 文件中的 API KEY 正确
2. 网络可以访问 API 服务
3. API 账户有足够余额

### Q2: 依赖安装失败

```bash
# 升级 pip
pip install --upgrade pip

# 单独安装依赖
pip install crewai
pip install crewai-tools
```

### Q3: 内存不足

如果运行大型模型时内存不足，可以：
1. 使用更小的模型（如 gpt-4o-mini）
2. 增加 swap 空间
3. 减少并发任务数

---

## 扩展指南

### 添加新 Agent

```python
def create_new_agent():
    return Agent(
        role="新角色名称",
        goal="角色目标",
        backstory="角色背景描述",
        tools=[web_search],  # 添加工具
        verbose=True
    )
```

### 添加新工具

```python
@tool("新工具名称")
def new_tool(param: str) -> str:
    """工具描述"""
    # 工具实现
    return result
```

### 集成到 OpenClaw

1. 将 Agent 定义转换为 OpenClaw 格式
2. 使用 OpenClaw 的 MCP 接口调用
3. 配置工作流调度

---

## 总结

本教程提供了：

- ✅ 完整的项目结构
- ✅ 基础版和高级版代码
- ✅ 多种运行模式
- ✅ 常见问题解决方案
- ✅ 扩展指南

按照本教程操作，您可以在 30 分钟内搭建起一个可用的 AI 公司系统。

如需进一步定制，请参考：
- [CrewAI 官方文档](https://docs.crewai.com)
- [LangChain 工具文档](https://python.langchain.com/docs/integrations/tools/)
